#!/usr/bin/env python
from subprocess import call, Popen, PIPE
from argh import *
import itertools
import socket
import cjdns
import utils
import json
import time
import os

CJDNS_GIT_REPO = 'https://github.com/cjdelisle/cjdns.git'
CJDNS_CLONE_DIR = '/opt/cjdns'

YRD_GIT_REPO = 'https://github.com/kpcyrd/yrd.git'
YRD_CLONE_DIR = '/opt/yrd'
YRD_FOLDER = '/var/lib/yrd'
YRD_PEERS = '/var/lib/yrd/peers.d'
CJDROUTE_CONF = '/var/lib/yrd/cjdroute.conf'


def install():
    'install yrd and cjdns on your box'

    yield '[*] checking permissions'
    if os.geteuid():
        yield '[-] you need to be root'
        return

    yield '[*] checking if we have git and gcc'
    if call(['which', 'git']) or call(['which', 'gcc']):
        yield '[/] somethings missing, checking if we can install it'
        if not call(['which', 'apt-get']):
            yield '[*] installing what\'s missing'

            if call(['apt-get', 'install', 'build-essential', 'git']):
                yield '[-] installation failed, please install them yourself'
                return
        else:
            yield '[-] we can\'t do this automatically on your system'
            return

    yield '[*] checking if cjdroute is there'
    if call(['which', 'cjdroute']):
        yield '[/] not found, continuing'

        yield '[*] cloning cjdns'
        if call(['git', 'clone', CJDNS_GIT_REPO, CJDNS_CLONE_DIR]):
            yield '[-] clone failed'
            return

        yield '[*] compiling cjdns'
        if call(['sh', '-c', 'cd "%s" && ./do' % CJDNS_CLONE_DIR]):
            yield '[-] compile failed'

        yield '[*] creating symlink'
        os.symlink(os.path.join(CJDNS_CLONE_DIR, 'cjdroute'),
                   '/usr/bin/cjdroute')
    else:
        yield '[+] already installed, skipping'

    yield '[*] checking if yrd is in your path'
    if call(['which', 'yrd']):
        yield '[/] not in your path, doing a proper install from scratch'
        yield '[*] cloning yrd'
        if call(['git', 'clone', YRD_GIT_REPO, YRD_CLONE_DIR]):
            yield '[-] clone failed'
            return

        yield '[*] creating symlink'
        os.symlink(os.path.join(YRD_CLONE_DIR, 'yrd'),
                   '/usr/bin/yrd')
    else:
        yield '[+] already installed, skipping'

    yield '[*] checking folders for internal files'
    for folder in [YRD_FOLDER, YRD_PEERS]:
        if not os.path.exists(folder):
            yield '[*] creating ' + folder
            os.mkdir(folder, 0700)

    yield '[+] installation complete'


@wrap_errors([KeyboardInterrupt])
def start():
    with open(CJDROUTE_CONF) as f:
        conf = f.read()

    p = Popen(['cjdroute'], stdin=PIPE)
    p.communicate(conf)

    conf = json.loads(conf)

    c = cjdns.connect(password=conf['admin']['password'])

    for peer in os.listdir(YRD_PEERS):
        with open(os.path.join(YRD_PEERS, peer)) as f:
            info = json.load(f)
            if info['type'] == 'in':
                c.addPassword(info['name'], info['password'])
            elif info['type'] == 'out':
                addr = utils.dns_resolve(info['addr'])
                c.udp_begin_connection(str(addr), str(info['pk']),
                                       str(info['password']))

    c.disconnect()


@wrap_errors([socket.error])
def addr():
    'show infos about your node'
    c = cjdns.connect()
    res = c.lookup()['result']
    table = list(c.dumpTable())

    yield 'addr\t\t' + res['bestParent']['ip']
    yield 'key\t\t' + res['key']
    yield 'version\t\tv' + str(res['protocolVersion'])
    yield ''
    yield 'links\t\t' + str(res['linkCount'])
    yield 'known routes\t' + str(len(table))

    c.disconnect()


@arg('ip', help='the cjdns ipv6')
@arg('-c', '--count', metavar='count', help='stop after `count` packets')
@arg('-s', '--switch', help='do a switch ping instead of a router ping')
@wrap_errors([KeyboardInterrupt, socket.error])
def ping(ip, count=0, switch=False):
    'ping a node'
    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    c = cjdns.connect(password=conf['admin']['password'])

    ping = c.switchPing if switch else c.routerPing

    for _ in xrange(count) if count else itertools.repeat(None):
        resp = ping(ip)

        if 'error' in resp:
            yield 'Error: %s' % resp['error']
        elif resp['result'] == 'pong':
            yield 'Reply from %s %dms' % (resp['from'], resp['ms'])
        elif resp['result'] == 'timeout':
            yield 'Timeout from %s after %dms' % (ip, resp['ms'])

        time.sleep(1)

    c.disconnect()


@arg('-f', '--verify', help='verify the selected route')
@wrap_errors([KeyboardInterrupt, socket.error])
def tr(target, verify=False):
    'traceroute a node'
    c = cjdns.connect()

    if verify:
        res = c.lookup()['result']
        lastHop = res['bestParent']['ip']

        print(lastHop)

        while True:
            x = c.nextHop(target, lastHop)
            # TODO: implement
            return
    else:
        found = 0
        for route in c.dumpTable():
            if route['ip'] != target:
                continue

            found += 1

            yield '[+] found route #%d' % found
            # TODO: show the route

    c.disconnect()


@arg('-f', '--follow', help='show new nodes while they\'re discovered')
@wrap_errors([KeyboardInterrupt, socket.error])
def r(follow=False):
    'access the nodestore'
    c = cjdns.connect()

    known = []
    FMT = '%s %s  v%d %11d %7d'

    while True:
        for node in c.dumpTable():
            if node['ip'] not in known:
                yield FMT % (node['ip'], node['path'], node['version'],
                             node['link'], node['time'])

                known.append(node['ip'])

        if not follow:
            break

        time.sleep(3)

    c.disconnect()


@arg('-n', '--neighbours', help='show neighbours peers')
@aliases('neighbours')
@wrap_errors([socket.error])
def n(neighbours=False):
    'shows your neighbours'

    if neighbours:
        with open(CJDROUTE_CONF) as f:
            conf = json.load(f)

        c = cjdns.connect(password=conf['admin']['password'])
    else:
        c = cjdns.connect()

    STAT_FORMAT = '%s %19s  v%d  %7d %7d  %12s  %d/%d/%d  '
    nodestore = list(c.dumpTable())

    for peer in c.getPeers():
        result = c.lookup(peer.ip)['result']

        route = utils.grep_ns(nodestore, peer.ip)
        path = utils.get_path(route)

        setattr(peer, 'path', path)

        line = STAT_FORMAT % (peer.ip, peer.path, peer.version,
                              peer.bytesIn, peer.bytesOut, peer.state,
                              peer.duplicates, peer.lostPackets,
                              peer.receivedOutOfRange)

        if hasattr(peer, 'user'):
            line += repr(peer.user)

        print(line)

        if neighbours:
            for i in range(result['linkCount']):
                link = c.getLink(peer.ip, i)

                if link and 'child' in link['result']:
                    child = link['result']['child']
                    route = utils.grep_ns(nodestore, child)

                    version = utils.get_version(route)
                    path = utils.get_path(route)

                    print('   %s   %s  v%s' % (child, path, version))
                else:
                    print('   -')

    c.disconnect()


@arg('-t', '--trace', help='')
def uplinks(ip, trace=False):
    'show uplinks of a node'
    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    c = cjdns.connect(password=conf['admin']['password'])
    nodestore = list(c.dumpTable())

    result = c.lookup(ip)['result']
    for i in range(result['linkCount']):
        link = c.getLink(ip, i)

        if link and 'child' in link['result']:
            child = link['result']['child']
            route = utils.grep_ns(nodestore, child)

            version = utils.get_version(route)
            path = utils.get_path(route)

            yield '%s   %s  v%d' % (child, path, version)
        else:
            yield('-')

    c.disconnect()


@named('auth')
@wrap_errors([socket.error])
def peer_auth(name):
    'add a password for inbound connections'

    if '/' in name:
        yield 'nope'
        exit(1)

    path = os.path.join(YRD_PEERS, name)
    if os.path.exists(path):
        with open(path) as f:
            password = json.load(f)['password']
    else:
        password = utils.generate_key(31)

        info = {
            'type': 'in',
            'name': name,
            'password': password
        }

        with open(path, 'w') as f:
            f.write(json.dumps(info))

    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    c = cjdns.connect(password=conf['admin']['password'])
    c.addPassword(name, password)
    c.disconnect()

    publicKey = conf['publicKey']
    port = conf['interfaces']['UDPInterface'][0]['bind'].split(':')[1]

    yield utils.to_credstr(utils.get_ip(), port, publicKey, password)


@named('ls')
def peer_ls():
    'list passwords for inbound connections'
    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    c = cjdns.connect(password=conf['admin']['password'])
    for user in c.listPasswords()['users']:
        yield user
    c.disconnect()


@named('add')
def peer_add(name, addr, pk, password):
    'add an outbound connection'
    if '/' in name:
        yield 'nope'
        exit(1)

    path = os.path.join(YRD_PEERS, name)

    info = {
        'type': 'out',
        'name': name,
        'addr': addr,
        'pk': pk,
        'password': password
    }

    with open(path, 'w') as f:
        f.write(json.dumps(info))

    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    addr = utils.dns_resolve(addr)

    c = cjdns.connect(password=conf['admin']['password'])
    c.udp_begin_connection(addr, pk, password)
    c.disconnect()


@named('remove')
def peer_remove(user):
    'unpeer a node'
    if '/' in user:
        yield 'nope'
        exit(1)

    path = os.path.join(YRD_PEERS, user)
    if os.path.exists(path):
        os.unlink(path)
    else:
        yield 'user not found'

    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    c = cjdns.connect(password=conf['admin']['password'])
    c.removePassword(user)
    c.disconnect()


@named('get')
def dht_get(*trackers):
    'query public peers'
    import dht
    for tracker in trackers:
        for peer in dht.request_peers(tracker):
            yield peer.credentialstr()


@named('peer')
def dht_peer():
    'connect to public peers'
    import dht
    pass


@arg('tracker', help='the tracker you want to announce on')
@arg('password', help='the password you want to share')
@arg('-1', '--oneshot', help='if you want to announce per cronjob')
@arg('contact', nargs='?', help='if you want to allow contact')
@named('announce')
@wrap_errors([KeyboardInterrupt])
def dht_announce(tracker, password, contact, oneshot=False):
    'announce yourself as public peer'
    import dht

    with open(CJDROUTE_CONF) as f:
        conf = json.load(f)

    addr = conf['interfaces']['UDPInterface'][0]['bind']
    peer = {
        'port': int(addr.split(':')[1]),
        'publicKey': conf['publicKey'],
        'password': password
    }

    if contact:
        peer['contact'] = contact

    while True:
        try:
            if dht.announce(tracker, **peer):
                yield '[+] Told the tracker we\'re here'
        except (IOError, ValueError), e:
            yield '[-] %s' % e

        if oneshot:
            break

        time.sleep(120)


parser = ArghParser()
parser.add_commands([install, start, addr, n, ping, tr, r, uplinks])
parser.add_commands([peer_auth, peer_add, peer_ls, peer_remove],
                    namespace='peer', title='ctrl peers')
parser.add_commands([dht_get, dht_peer, dht_announce],
                    namespace='dht', title='ctrl inet auto-peering')

if __name__ == '__main__':
    dispatch(parser)
